//! `analyzer` is a module containing the packet analysis and reporting logic.

use crate::{
    listener::{self, PacketWrapper},
    proto::{bootp::OpCode, dhcp::v4},
};

use chrono::{DateTime, Local};
use serde::{Deserialize, Serialize};

use simple_moving_average::*;

/// A default length of the Ethernet frame, IP and UDP headers together.
const ETHERNET_IP_UDP_HEADER_LENGTH: usize = 42;

/// A structure receiving a current report from the DHCPv4 auditors.
///
/// The [`Analyzer::current_dhcpv4_report`] function takes this structure
/// as a parameter and the DHCPv4 auditors are responsible for filling
/// their respective fields with the current audit results.
///
/// The structure must be extended with additional fields for new auditors,
/// when they are implemented.
///
/// The report is serialized to the CSV format.
#[derive(Serialize, Deserialize)]
pub struct DHCPv4Report {
    /// Report generation time.
    ///
    /// The value of this field is generated by the [`Analyzer`] when it receives
    /// the reports from the auditors. The auditors must not modify this field.
    time: DateTime<Local>,
    /// Percentage of the received `BootRequest` messages.
    ///
    /// This metric is maintained by the [`OpCodeAuditor`].
    opcode_boot_requests_percent: f64,
    /// Percentage of the received `BootReply` messages.
    ///
    /// This metric is maintained by the [`OpCodeAuditor`].
    opcode_boot_replies_percent: f64,
    /// Percentage of the messages with an invalid `opcode`.
    ///
    /// An invalid field is neither `BootRequest` nor `BootReply`.
    /// This metric is maintained by the [`OpCodeAuditor`].
    opcode_invalid_percent: f64,
    /// Percentage of the DHCPv4 client retransmissions.
    ///
    /// It indicates how many percent of the received `BootRequest` messages
    /// have an elevated `secs` field value.
    ///
    /// This metric is maintained by the [`RetransmissionAuditor`].
    retransmit_percent: f64,
    /// Average `secs` field value in the received client messages.
    ///
    /// This metric is maintained by the [`RetransmissionAuditor`].
    retransmit_secs_avg: f64,
}

impl DHCPv4Report {
    /// Instantiates new report.
    ///
    /// It sets default values to all metrics. It also sets the current
    /// time for the [`DHCPv4Report::time`] field.
    fn new() -> DHCPv4Report {
        DHCPv4Report{
            time: Local::now(),
            opcode_boot_requests_percent: 0.0,
            opcode_boot_replies_percent: 0.0,
            opcode_invalid_percent: 0.0,
            retransmit_percent: 0.0,
            retransmit_secs_avg: 0.0,
        }
    }
}

/// A trait that must be implemented by each DHCPv4 auditor.
///
/// The [`Analyzer`] calls the [`DHCPv4PacketAuditor::audit`] function
/// for each received BOOTP packet. The auditor runs specialized
/// checks on the packet and updates its local state and maintained
/// metrics. The [`Analyzer`] can call [`DHCPv4PacketAuditor::receive_report`]
/// to gather the metrics from the auditor periodically.
pub trait DHCPv4PacketAuditor {
    /// Runs an audit on the received packet.
    ///
    /// The audit is specific to the given auditor implementing this
    /// trait. The auditor maintains some specific metrics gathered
    /// from the constant analysis of the received packets. It may
    /// discard some of the packets that don't meet the audit criteria.
    ///
    /// For example: an auditor checking client retransmissions should
    /// ignore the replies from the server and return immediately.
    ///
    /// # Parameters
    ///
    /// - `packet` - a partially parsed `DHCPv4` or `BOOTP` packet to be audited
    fn audit<'a>(&mut self, packet: &mut v4::PartiallyParsedPacket<'a>);

    /// Reports auditor's metrics in the global report to the [`Analyzer`].
    ///
    /// This function is called by the [`Analyzer`] for each auditor. The
    /// auditor should respond by returning its metrics in the provided
    /// `report`.
    ///
    /// # Parameters
    ///
    /// - `report` - mutable reference to the report in which the auditor
    ///              is supposed to set its metrics
    fn receive_report(&mut self, report: &mut DHCPv4Report);
}

/// A central instance receiving the captured packets and performing their
/// analysis using available auditors.
///
/// It recognizes received packet types and selects appropriate auditors
/// to perform the analysis.
pub struct Analyzer {
    /// DHCPv4 auditors.
    dhcpv4_auditors: Vec<Box<dyn DHCPv4PacketAuditor>>,
}

impl Analyzer {
    /// Instantiates the [`Analyzer`].
    pub fn new() -> Self {
        Analyzer {
            dhcpv4_auditors: Vec::new(),
        }
    }

    /// Installs all default auditors.
    pub fn add_default_auditors(&mut self) {
        self.dhcpv4_auditors.push(RetransmissionAuditor::new());
        self.dhcpv4_auditors.push(OpCodeAuditor::new());
    }

    /// Runs analysis of the received packet.
    ///
    /// It checks the packet type and picks appropriate set of auditors
    /// for the analysis.
    ///
    /// # Parameters
    ///
    /// - `packet` - a wrapper containing the captured packet and its metadata
    pub fn receive<'a>(&mut self, packet: PacketWrapper) {
        match packet.filter {
            Some(filter) => match filter.get_proto() {
                Some(listener::Proto::Bootp) => {
                    // We are assuming that it is an Ethernet frame, which is fine for
                    // most cases. In this case the DHCP payload starts at the offset
                    // of 42 which is a sum of the Ethernet, IP and UDP headers.
                    if packet.data.len() > ETHERNET_IP_UDP_HEADER_LENGTH {
                        let packet = v4::ReceivedPacket::new(&packet.data[ETHERNET_IP_UDP_HEADER_LENGTH..]);
                        self.audit_dhcpv4(&packet);
                    }
                }
                _ => {}
            },
            None => {}
        }
    }

    /// Audits a DHCPv4 packet.
    ///
    /// # Parameters
    ///
    /// - `packet` - a received unparsed DHCPv4 packet
    fn audit_dhcpv4<'a>(&mut self, packet: &v4::RawPacket<'a>) {
        let mut packet = packet.into_parsable();
        for auditor in self.dhcpv4_auditors.iter_mut() {
            auditor.audit(&mut packet)
        }
    }

    /// Returns the current report from all DHCPv4 auditors.
    ///
    /// # Usage
    ///
    /// Typically, this function is called periodically to make the report
    /// available to an external reader (e.g., to append the report as a
    /// row of a CSV file or to a Prometheus exporter).
    pub fn current_dhcpv4_report(&mut self) -> DHCPv4Report {
        let mut report = DHCPv4Report::new();
        // Go over the active auditors and gather their metrics.
        for auditor in self.dhcpv4_auditors.iter_mut() {
            auditor.receive_report(&mut report);
        }
        report
    }
}

/// An auditor maintaining the statistics of the `BOOTP` message types.
///
/// It recognizes `BootRequest` and `BootReply` messages and maintains
/// an average percentage of each message type in the received packets
/// stream.
///
/// # Metrics
///
/// Keeping track of the `BootRequest` and `BootReply` message types can
/// be useful to detect situations when a DHCP server is unable to keep up
/// with the traffic. Another extreme case is when the are only `BootRequest`
/// messages and no `BootReply`. It indicates that the server is down
/// or misconfigured.
///
/// The auditor also returns an average number of invalid messages
/// (i.e., neither `BootRequest` nor `BootReply`).
pub struct OpCodeAuditor {
    boot_requests: NoSumSMA<f64, f64, 100>,
    boot_replies: NoSumSMA<f64, f64, 100>,
    invalid: NoSumSMA<f64, f64, 100>,
}

impl OpCodeAuditor {
    /// Instantiates the [`OpCodeAuditor`].
    pub fn new() -> Box<dyn DHCPv4PacketAuditor> {
        Box::new(OpCodeAuditor {
            boot_requests: NoSumSMA::new(),
            boot_replies: NoSumSMA::new(),
            invalid: NoSumSMA::new(),
        })
    }
}

impl DHCPv4PacketAuditor for OpCodeAuditor {
    fn audit<'a>(&mut self, packet: &mut v4::PartiallyParsedPacket<'a>) {
        match packet.opcode() {
            Ok(opcode) => match opcode {
                OpCode::BootRequest => {
                    self.boot_requests.add_sample(1.0);
                    self.boot_replies.add_sample(0.0);
                    self.invalid.add_sample(0.0)
                }
                OpCode::BootReply => {
                    self.boot_requests.add_sample(0.0);
                    self.boot_replies.add_sample(1.0);
                    self.invalid.add_sample(0.0)
                }
                OpCode::Invalid(_) => {
                    self.boot_requests.add_sample(0.0);
                    self.boot_replies.add_sample(0.0);
                    self.invalid.add_sample(1.0)
                }
            },
            Err(_) => {}
        };
    }

    fn receive_report(&mut self, report: &mut DHCPv4Report) {
        report.opcode_boot_requests_percent = 100.0 * self.boot_requests.get_average();
        report.opcode_boot_replies_percent = 100.0 * self.boot_replies.get_average();
        report.opcode_invalid_percent = 100.0 * self.invalid.get_average();
    }
}

/// An auditor maintaining the statistics of DHCP retransmissions.
///
/// The auditor looks into the `secs` field of the `BOOTP` messages. If this
/// field has a value greater than zero it indicates that the client has been
/// unable to allocate a lease in the previous attempts and retransmits.
///
/// # Metrics
///
/// Client retransmissions often occur when the server is unable to keep up
/// with the DHCP traffic load. A high average value of the `secs` field and
/// a high average number of retransmissions indicate that the server has
/// hard time to keep up with the traffic.
pub struct RetransmissionAuditor {
    retransmits: NoSumSMA<f64, f64, 100>,
    secs: NoSumSMA<f64, f64, 100>,
}

impl RetransmissionAuditor {
    /// Instantiates the [`RetransmissionAuditor`].
    pub fn new() -> Box<dyn DHCPv4PacketAuditor> {
        Box::new(RetransmissionAuditor {
            retransmits: NoSumSMA::new(),
            secs: NoSumSMA::new(),
        })
    }
}

impl DHCPv4PacketAuditor for RetransmissionAuditor {
    fn audit<'a>(&mut self, packet: &mut v4::PartiallyParsedPacket<'a>) {
        let opcode = packet.opcode();
        if opcode.is_err() || opcode.is_ok() && opcode.unwrap().ne(&OpCode::BootRequest) {
            return;
        }
        match packet.secs() {
            Ok(secs) => {
                if secs > 0 {
                    self.retransmits.add_sample(1.0);
                } else {
                    self.retransmits.add_sample(0.0);
                }
                self.secs.add_sample(secs as f64);
            }
            Err(_) => {}
        };
    }

    fn receive_report(&mut self, report: &mut DHCPv4Report) {
        report.retransmit_percent = 100.0 * self.retransmits.get_average();
        report.retransmit_secs_avg = self.secs.get_average();
    }
}

#[cfg(test)]
mod tests {
    use crate::{analyzer::RetransmissionAuditor, proto::{bootp::*, dhcp::v4::ReceivedPacket, tests::common::TestBootpPacket}};
    use super::{Analyzer, DHCPv4Report, OpCodeAuditor};

    #[test]
    fn dhcpv4_analysis() {
        let mut analyzer = Analyzer::new();
        analyzer.add_default_auditors();
        for i in 0..10 {
            let test_packet = TestBootpPacket::new();
            let test_packet = test_packet
                .set(OPCODE_POS, &vec![1])
                .set(SECS_POS, &vec![0, i]);
            let packet = ReceivedPacket::new(&test_packet.get());
            analyzer.audit_dhcpv4(&packet);
        }
        let report = analyzer.current_dhcpv4_report();
        assert_eq!(0.0, report.opcode_boot_replies_percent);
        assert_eq!(100.0, report.opcode_boot_requests_percent);
        assert_eq!(0.0, report.opcode_invalid_percent);
        assert_eq!(90.0, report.retransmit_percent);
        assert_eq!(4.5, report.retransmit_secs_avg);
    }

    #[test]
    fn opcode_audit() {
        let mut auditor = OpCodeAuditor::new();
        let test_packet = TestBootpPacket::new();
        let test_packet = test_packet
            .set(OPCODE_POS, &vec![1]);
        let packet = &mut ReceivedPacket::new(&test_packet.get()).into_parsable();
        // Audit 5 request packets. They should constitute 100% of all packets.
        for _ in 0..5 {
            auditor.audit(packet);
        }
        let mut report = DHCPv4Report::new();
        auditor.receive_report(&mut report);
        assert_eq!(100.0, report.opcode_boot_requests_percent);
        assert_eq!(0.0, report.opcode_boot_replies_percent);
        assert_eq!(0.0, report.opcode_invalid_percent);

        // Audit 3 reply packets. Now we have 8 packets audited (62.5% are requests and 37.5%
        // are replies).
        let test_packet = test_packet
            .set(OPCODE_POS, &vec![2]);
        let packet = &mut ReceivedPacket::new(&test_packet.get()).into_parsable();
        for _ in 0..3 {
            auditor.audit(packet);
        }
        auditor.receive_report(&mut report);
        assert_eq!(62.5, report.opcode_boot_requests_percent);
        assert_eq!(37.5, report.opcode_boot_replies_percent);
        assert_eq!(0.0, report.opcode_invalid_percent);

        // Finally, let's add some 2 invalid packets with opcode 3. We have a total of 10 packets
        // (50% of requests, 30% of replies and 20% invalid).
        let test_packet = test_packet
        .set(OPCODE_POS, &vec![3]);
        let packet = &mut ReceivedPacket::new(&test_packet.get()).into_parsable();
        for _ in 0..2 {
            auditor.audit(packet);
        }
        auditor.receive_report(&mut report);
        assert_eq!(50.0, report.opcode_boot_requests_percent);
        assert_eq!(30.0, report.opcode_boot_replies_percent);
        assert_eq!(20.0, report.opcode_invalid_percent);
    }

    #[test]
    fn retransmissions_audit() {
        let mut auditor = RetransmissionAuditor::new();
        let test_packet = TestBootpPacket::new();
        let test_packet = test_packet
            .set(OPCODE_POS, &vec![1])
            .set(SECS_POS, &vec![0, 0]);
        let packet = &mut ReceivedPacket::new(&test_packet.get()).into_parsable();

        // Audit the packet having secs field value of 0. It doesn't count as retransmission.
        auditor.audit(packet);
        let mut report = DHCPv4Report::new();
        auditor.receive_report(&mut report);
        assert_eq!(0.0, report.retransmit_percent);
        assert_eq!(0.0, report.retransmit_secs_avg);

        // Audit 4 packets. The first is not a retransmission. The remaining ones
        // have the increasing secs value.
        for i in 0..4 {
            let test_packet = TestBootpPacket::new()
                .set(OPCODE_POS, &vec![1])
                .set(SECS_POS, &vec![0, i]);
            let packet = &mut ReceivedPacket::new(&test_packet.get()).into_parsable();
            auditor.audit(packet);
        }
        // 60% of packets were retransmissions. The average secs field value was 1.2.
        auditor.receive_report(&mut report);
        assert_eq!(60.0, report.retransmit_percent);
        assert_eq!(1.2, report.retransmit_secs_avg);
    }

}
